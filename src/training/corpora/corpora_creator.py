from typing import List
import numpy as np
import matplotlib.pyplot as plt

import pathlib

from src.consts import CORPORA_DIR, CORPORA_DELIMETER, RAW_DATA_20K, RAW_TEST_DATA_100

# logger
from src.logger.logger import setup_logger

logger = setup_logger(__name__)

class CorporaCreator:
    """
        The task of this class is to convert raw games history generated by the
        cpp scipt into LLM friendly format that could be utilized for training.

        Based on specific raw data class can create multiple corpora types.
    """

    def __init__(self, delimenter: str, path_to_raw_data: pathlib.Path):
        self.delimeter = delimenter
        self.path_to_raw_data = path_to_raw_data
        # print(self.games[1])
    
    def load_raw_data(self):

       
        games = []

        with open(self.path_to_raw_data, 'r') as file:
            lines = file.readlines()

        

        i = 0
        current_game = None
        while i < len(lines):
            
            line = lines[i].strip()

            # beginning of a new game
            if line.startswith(self.delimeter):
                if current_game != None:
                    games.append(current_game)

                current_game = {
                    "turns": 0,
                    "snakes": [],
                    "apples": []
                }

                i += 1
                continue

            if line.startswith("Turns"):
                current_game['turns'] = int(line.split()[1])
                i+=1
                continue

            # Parse snake information
            if line.startswith('Length:'):
                # snake_length = int(line.split()[1])
                # skip length
                i += 1
                snake_id = int(lines[i].strip().split()[1])
                i += 1
                
                # Parse snake positions
                positions_line = lines[i].strip()
                positions = []
                position_pairs = positions_line.split(') (')
                
                for pair in position_pairs:
                    # Clean up the pairs
                    pair = pair.replace('(', '').replace(')', '')
                    x, y = map(int, pair.split(','))
                    positions.append((x, y))

                # go to tail lengths
                i += 2
                # print(lines[i].split())
                tail_lengths = [int(l) for l in lines[i].split()]
                
                snake_data = {
                    'id': snake_id,
                    'positions': positions,
                    'tail_lengths': tail_lengths
                }
                
                current_game['snakes'].append(snake_data)
                i += 1
                continue

            # Parse apple information
            if line.startswith("Apple"):
                apple_data = []

                i += 1 # move to the next line
                
                while i < len(lines) and not lines[i].strip().startswith(self.delimeter):
                    line = lines[i].strip()
                    if not line:
                        i += 1
                        continue
                    
                    # Check if we've reached a new section
                    if line.startswith('Length:') or line.startswith('Turns'):
                        break
                    
                    parts = line.split()
                    
                    # Extract apple positions and turn number
                    apple_positions = []
                    for j in range(len(parts) - 1):
                        if '(' in parts[j]:
                            apple_pos = parts[j].replace('(', '').replace(')', '').split(',')
                            apple_positions.append((int(apple_pos[0]), int(apple_pos[1])))
                    
                    turn = int(parts[-1])
                    
                    apple_data.append({
                        'positions': apple_positions,
                        'turn': turn
                    })
                    
                    i += 1
                
                current_game['apples'] = apple_data
                continue
            
            i += 1

        return games


    def get_statistics(self, corpora_folder: pathlib.Path, stats_of_filename: pathlib.Path):
        """
            Create statistics for a given corpora.
            Input arguments are the folder and file paths for
            the corpora statistics will be based on.
        """
        games = []
        # each game is written in a separate line
        corpora_path = corpora_folder / stats_of_filename
        with open(corpora_path, 'r') as file:
            [games.append(line) for line in file]
        
        # remove any empty games that might result from splitting
        games = [game.strip() for game in games if game.strip()]

        # calcualte tokens amount, tokenization is on split
        token_counts = [len(game.split()) for game in games]

        max_counts = []
        for game in games:
            words = game.split()
            s1_count = words.count("S1")
            s0_count = words.count("S0")
            max_counts.append(s1_count + s0_count)

        overall_max = max(max_counts) if max_counts else 0
        
        # Calculate statistics
        stats = {
            "total_games": len(games),
            "token-wize": {
                "min": min(token_counts),
                "max": max(token_counts),
                "mean": np.mean(token_counts),
                "median": np.median(token_counts),
                "p90": np.percentile(token_counts, 90),
            },
            "max_turns": overall_max
        }
        
        # Create histograms
        fig, ax1 = plt.subplots(1, 1, figsize=(15, 5))
        
        
        # Tokens histogram
        ax1.hist(token_counts, bins=30, alpha=0.7, color='green')
        ax1.set_title('Game Length Distribution (by tokens)')
        ax1.set_xlabel('Number of Tokens')
        ax1.set_ylabel('Frequency')
        ax1.axvline(stats["token-wize"]["median"], color='r', linestyle='dashed', linewidth=1, label=f'Median: {stats["token-wize"]["median"]:.1f}')
        ax1.axvline(stats["token-wize"]["p90"], color='g', linestyle='dashed', linewidth=1, label=f'90th %: {stats["token-wize"]["p90"]:.1f}')
        ax1.legend()
        
        plt.tight_layout()
        plt.savefig(corpora_folder / f"{stats_of_filename.stem}_game_length_distr.png")
        plt.show()


        stats_file = stats_of_filename.stem + "_stats.txt"
        with open(corpora_folder / stats_file, 'w+') as file:
            token_stats = stats['token-wize']
            file.write(f"Total Games: {stats['total_games']}\n"
                    f"Max Game Length: {token_stats['max']}\n"
                    f"Min Game Length: {token_stats['min']}\n"
                    f"Average Game Length: {token_stats['mean']}\n"
                    f"Median Game Length: {token_stats['median']}\n"
                    f"90th percentile: {token_stats['p90']}\n"
                    f"Max turn length: {stats['max_turns']}\n")
    
    def parse_raw_data_to_tokens(self):
        """
            Takes data from raw data and returns games in a form of:
            <START> S0 R8C0 L0 A39 A90 A17 A88 A73 S1 R8C2 L0 A39 A90 A17 A88 A73 S0 R9C0 L1 ...
        """

        self.games = self.load_raw_data()


        corpora = []
        for game in self.games:

            TURNS = game["turns"]
            SNAKES = game["snakes"]
            APPLES = game["apples"]

            
            corp_line = "<START> "


            # THIS INITIAL CONFIGURATION OCCURES IN THE Oth TURN (so odd turns are Snake0 moves)

            # since snake history and and apple history begins with inital apples postions and initial
            # snake heads postitions, first tokens are the initial state, apple tokens are apples after each move
            # so initial state looks something like this:
            # [Snake0_positions[0]] [apples_positions[0]] [Snake1_positions[1]] [apples_positions[0]] [normal game with move and apples state after each move]

            # we need to have indices this way, since some turns are just skip turns
            # we don't save apples or snake positions in them
            # list of current index for position in a given snake
            si = [1 for _ in range(len(SNAKES))]
            
            # set up initial snakes and apples positions
            apple_i = 0
            
            # [Snake0_positions[0]]
            corp_line += f'S0 R{SNAKES[0]["positions"][0][0]}C{SNAKES[0]["positions"][0][1]} L{SNAKES[0]["tail_lengths"][0]} '
            # [apples_positions[0]]
            corp_line += " ".join([f'A{r}{c}' for r,c in APPLES[apple_i]["positions"]])
            corp_line += " "

         
            # [Snake1_positions[1]]
            corp_line += f'S1 R{SNAKES[1]["positions"][0][0]}C{SNAKES[1]["positions"][0][1]} L{SNAKES[1]["tail_lengths"][0]} '
            # [apples_positions[0]]
            corp_line += " ".join([f'A{r}{c}' for r,c in APPLES[apple_i]["positions"]])
            corp_line += " "

            apple_i = 1

            # TURNS + 1 since last turn is also imporant (has a move that resulted in death of the other snake)
            for turn in range(1, TURNS+1):
                
                # 0th snake if move exists
                if (turn-1) % 2 == 0:
                    if si[0] < len(SNAKES[0]["positions"]):
                        # S0 12 7 -> Snake0 is on position (1,2) and has a tail of length 7
                        corp_line += f'S0 R{SNAKES[0]["positions"][si[0]][0]}C{SNAKES[0]["positions"][si[0]][1]} L{SNAKES[0]["tail_lengths"][si[0]]} '
                        # after a move save apple position
                        if apple_i < len(APPLES):
                            corp_line += " ".join([f'A{r}{c}' for r,c in APPLES[apple_i]["positions"]])
                            # corp_line += " "
                            apple_i += 1

                        si[0] += 1
                    else:
                        corp_line += f'S0 <DEAD> L{SNAKES[0]["tail_lengths"][-1]} '
                        corp_line += " ".join([f'A{r}{c}' for r,c in APPLES[apple_i-1]["positions"]])

                # 1st snake if move exists
                elif (turn-1) % 2 == 1:
                    if si[1] < len(SNAKES[1]["positions"]):
                        # S1 12 7 -> Snake1 is on position (1,2) and has a tail of length 7
                        corp_line += f'S1 R{SNAKES[1]["positions"][si[1]][0]}C{SNAKES[1]["positions"][si[1]][1]} L{SNAKES[1]["tail_lengths"][si[1]]} '

                        # after a move save apple position
                        if apple_i < len(APPLES):
                            corp_line += " ".join([f'A{r}{c}' for r,c in APPLES[apple_i]["positions"]])
                            # corp_line += " "
                            apple_i += 1
                            

                        si[1] += 1
                    else:
                        corp_line += f'S1 <DEAD> L{SNAKES[1]["tail_lengths"][-1]} '
                        corp_line += " ".join([f'A{r}{c}' for r,c in APPLES[apple_i-1]["positions"]])
                
                corp_line += " "

            corpora.append(corp_line.strip() + ' <END>\n')

        return corpora
        


    def create_standard_position_corpora(self, output_folder: pathlib.Path, output_filename: pathlib.Path):
        
        standard_corpora = self.parse_raw_data_to_tokens()

        # clear the file and add data
        with open(output_folder / output_filename, 'w') as file:
            for game_line in standard_corpora:
                file.write(game_line) 

    def create_apple_corpora(self, output_folder: pathlib.Path, output_filename: pathlib.Path):
        """
            Creates corpora, where apple token is present only if it was recently added,
            no change in apples state results with a special token <APPLES_UNCHANGED>
        """

        standard_corpora = self.parse_raw_data_to_tokens()

        apple_corpora = []

        for game in standard_corpora:
            tokens = game.split()
            l = 0
            prev_apples = []
            corpline = ""

            while l < len(tokens):
                r = l
                while tokens[r].startswith("A"):
                    r += 1
                # window of apples was encountered
                if r != l:
                    # apples didn't change
                    if prev_apples == tokens[l:r]:
                        corpline += " <APPLES_UNCHANGED>"
                    else:
                        # apples changed, so just add the apple where they differ as apple
                        # leave only new apple
                        diff = list(set(tokens[l:r]) - set(prev_apples))
                        # logger.debug(prev_apples)
                        # logger.debug(tokens[l:r])
                        # logger.debug(diff)
                        # logger.debug(len(diff))
                        assert len(diff) == 1 or prev_apples == []
                        assert diff[0] in tokens[l:r]
                        assert diff[0] not in prev_apples
                        corpline += " " + " ".join([elem for elem in diff]) 


                    prev_apples = tokens[l:r]
                    # move window to the first, not apple token
                    l = r
                    

                # it wasn't a window of apples, so just add normal token
                else:
                    corpline += " " + tokens[l]
                    l += 1

            apple_corpora.append(corpline)

        with open(output_folder / output_filename, 'w+') as file:
            for game_line in apple_corpora:
                file.write(game_line + "\n")

        self.get_statistics(corpora_folder=output_folder, stats_of_filename=output_filename)

        



    def create_standard_corpora_aligned(self, output_folder: pathlib.Path, output_filename: pathlib.Path):
        """
            Creates corpora similar to standard version, but everything is aligned to the longest game.
        """
        
        standard_corpora = self.parse_raw_data_to_tokens()

        aligned_corpora = []

        # extract max length
        max_len = max(len(game.split()) for game in standard_corpora)

        # fill each line with padding_tokens so each line is of the same length
        for game in standard_corpora:
            game_len = len(game.split())
            fill_in_length = max_len - game_len
            padding_tokens_fill = " ".join(["<padding_token_0>" for _ in range(fill_in_length)])
            aligned_corpora.append(game.strip() + f" {padding_tokens_fill}\n")

        
        
        with open(output_folder / output_filename, 'w+') as file:
            for game_line in aligned_corpora:
                file.write(game_line) 





if __name__ == "__main__":
    creator = CorporaCreator(delimenter=CORPORA_DELIMETER, path_to_raw_data=RAW_DATA_20K)

    COPR_DIR = CORPORA_DIR / pathlib.Path("apples_corpora/")
    OUT_CORP_FILE = pathlib.Path("apples_corpora20k.txt")
    
    creator.create_apple_corpora(output_folder=COPR_DIR, output_filename=OUT_CORP_FILE)

    # COPR_DIR = CORPORA_DIR / pathlib.Path("standard_positions/")
    # OUT_CORP_FILE = pathlib.Path("standard_positions20kp.txt")

    # STANDARD POSITIONS GENERATION
    # creator.create_standard_position_corpora(
    #                         output_filename=OUT_CORP_FILE,
    #                         output_folder=COPR_DIR)
    
    

    # creator.get_statistics(corpora_folder=COPR_DIR, stats_of_filename=OUT_CORP_FILE)

    # ALIGNED POSITIONS GENERATOR

    # COPR_DIR = CORPORA_DIR / pathlib.Path("aligned_games/")
    # OUT_CORP_FILE = pathlib.Path("aligned_games20k.txt")

    # creator.create_standard_corpora_aligned(output_folder=COPR_DIR, output_filename=OUT_CORP_FILE)

    # creator.get_statistics(corpora_folder=COPR_DIR, stats_of_filename=OUT_CORP_FILE)
