from typing import List
import numpy as np
import matplotlib.pyplot as plt

import pathlib
import re

from src.consts import CORPORA_DIR, CORPORA_DELIMETER, RAW_DATA_20K, RAW_DATA_BFS_20K, RAW_TEST_DATA_10, GAMES_IN_RAW_FILE, TRAIN_VAL_SPLIT, RAW_DATA_TAILS_20K, RAW_DATA_MCTS_20K

# logger
from src.logger.logger import setup_logger

logger = setup_logger(__name__)

class CorporaCreator:
    """
        The task of this class is to convert raw games history generated by the
        cpp scipt into LLM friendly format that could be utilized for training.

        Based on specific raw data class can create multiple corpora types.
    """

    def __init__(self, delimenter: str, path_to_raw_data: pathlib.Path):
        self.delimeter = delimenter
        self.path_to_raw_data = path_to_raw_data
        # print(self.games[1])
    
    def load_raw_data(self):

       
        games = []

        with open(self.path_to_raw_data, 'r') as file:
            lines = file.readlines()

        

        i = 0
        current_game = None
        while i < len(lines):
            
            line = lines[i].strip()

            # beginning of a new game
            if line.startswith(self.delimeter):
                if current_game != None:
                    games.append(current_game)

                current_game = {
                    "turns": 0,
                    "snakes": [],
                    "apples": []
                }

                i += 1
                continue

            if line.startswith("Turns"):
                current_game['turns'] = int(line.split()[1])
                i+=1
                continue

            # Parse snake information
            if line.startswith('Length:'):
                # snake_length = int(line.split()[1])
                # skip length
                i += 1
                snake_id = int(lines[i].strip().split()[1])
                i += 1
                
                # Parse snake positions
                positions_line = lines[i].strip()
                positions = []
                position_pairs = positions_line.split(') (')
                
                for pair in position_pairs:
                    # Clean up the pairs
                    pair = pair.replace('(', '').replace(')', '')
                    x, y = map(int, pair.split(','))
                    positions.append((x, y))

                # go to tail lengths
                i += 2
                # print(lines[i].split())
                tail_lengths = [int(l) for l in lines[i].split()]
                # logger.debug(f"{ lines[i].strip()}")
                # go to tail last segment positions
                i += 2
                # logger.debug(f"{ lines[i].strip()}")
                segments_line = lines[i].strip()
                segments = []
                segment_pairs = segments_line.split(') (')
                for pair in segment_pairs:
                    # Clean up the pairs
                    pair = pair.replace('(', '').replace(')', '')
                    x, y = map(int, pair.split(','))
                    segments.append((x, y))
                
                snake_data = {
                    'id': snake_id,
                    'positions': positions,
                    'tail_lengths': tail_lengths,
                    'last_segments': segments
                }
                
                current_game['snakes'].append(snake_data)
                i += 1
                continue

            # Parse apple information
            if line.startswith("Apple"):
                apple_data = []

                i += 1 # move to the next line
                
                while i < len(lines) and not lines[i].strip().startswith(self.delimeter):
                    line = lines[i].strip()
                    if not line:
                        i += 1
                        continue
                    
                    # Check if we've reached a new section
                    if line.startswith('Length:') or line.startswith('Turns'):
                        break
                    
                    parts = line.split()
                    
                    # Extract apple positions and turn number
                    apple_positions = []
                    for j in range(len(parts) - 1):
                        if '(' in parts[j]:
                            apple_pos = parts[j].replace('(', '').replace(')', '').split(',')
                            apple_positions.append((int(apple_pos[0]), int(apple_pos[1])))
                    
                    turn = int(parts[-1])
                    
                    apple_data.append({
                        'positions': apple_positions,
                        'turn': turn
                    })
                    
                    i += 1
                
                current_game['apples'] = apple_data
                continue
            
            i += 1

        return games


    def get_statistics(self, corpora_folder: pathlib.Path, stats_of_filename: pathlib.Path):
        """
            Create statistics for a given corpora.
            Input arguments are the folder and file paths for
            the corpora statistics will be based on.
        """
        games = []
        # each game is written in a separate line
        corpora_path = corpora_folder / stats_of_filename
        with open(corpora_path, 'r') as file:
            [games.append(line) for line in file]
        
        # remove any empty games that might result from splitting
        games = [game.strip() for game in games if game.strip()]

        # calcualte tokens amount, tokenization is on split
        token_counts = [len(game.split()) for game in games]

        max_counts = []
        for game in games:
            words = game.split()
            s1_count = words.count("S1")
            s0_count = words.count("S0")
            max_counts.append(s1_count + s0_count)

        overall_max = max(max_counts) if max_counts else 0
        
        # Calculate statistics
        stats = {
            "total_games": len(games),
            "token-wize": {
                "min": min(token_counts),
                "max": max(token_counts),
                "mean": np.mean(token_counts),
                "median": np.median(token_counts),
                "p90": np.percentile(token_counts, 90),
            },
            "max_turns": overall_max
        }
        
        # Create histograms
        fig, ax1 = plt.subplots(1, 1, figsize=(15, 5))
        
        
        # Tokens histogram
        ax1.hist(token_counts, bins=30, alpha=0.7, color='green')
        ax1.set_title('Game Length Distribution (by tokens)')
        ax1.set_xlabel('Number of Tokens')
        ax1.set_ylabel('Frequency')
        ax1.axvline(stats["token-wize"]["median"], color='r', linestyle='dashed', linewidth=1, label=f'Median: {stats["token-wize"]["median"]:.1f}')
        ax1.axvline(stats["token-wize"]["p90"], color='g', linestyle='dashed', linewidth=1, label=f'90th %: {stats["token-wize"]["p90"]:.1f}')
        ax1.legend()
        
        plt.tight_layout()
        plt.savefig(corpora_folder / f"{stats_of_filename.stem}_game_length_distr.png")
        plt.show()


        stats_file = stats_of_filename.stem + "_stats.txt"
        with open(corpora_folder / stats_file, 'w+') as file:
            token_stats = stats['token-wize']
            file.write(f"Total Games: {stats['total_games']}\n"
                    f"Max Game Length: {token_stats['max']}\n"
                    f"Min Game Length: {token_stats['min']}\n"
                    f"Average Game Length: {token_stats['mean']}\n"
                    f"Median Game Length: {token_stats['median']}\n"
                    f"90th percentile: {token_stats['p90']}\n"
                    f"Max turn length: {stats['max_turns']}\n")
    
    def parse_raw_data_to_tokens(self) -> List[str]:
        """
            Takes data from raw data and returns games in a form of:
            <START> S0 R8C0 L0 A39 A90 A17 A88 A73 S1 R8C2 L0 A39 A90 A17 A88 A73 S0 R9C0 L1 ...
        """

        self.games = self.load_raw_data()


        corpora = []
        for game in self.games:

            TURNS = game["turns"]
            SNAKES = game["snakes"]
            APPLES = game["apples"]

            
            corp_line = "<START> "


            # THIS INITIAL CONFIGURATION OCCURES IN THE Oth TURN (so odd turns are Snake0 moves)

            # since snake history and and apple history begins with inital apples postions and initial
            # snake heads postitions, first tokens are the initial state, apple tokens are apples after each move
            # so initial state looks something like this:
            # [Snake0_positions[0]] [apples_positions[0]] [Snake1_positions[1]] [apples_positions[0]] [normal game with move and apples state after each move]

            # we need to have indices this way, since some turns are just skip turns
            # we don't save apples or snake positions in them
            # list of current index for position in a given snake
            si = [1 for _ in range(len(SNAKES))]
            
            # set up initial snakes and apples positions
            apple_i = 0
            
            # [Snake0_positions[0]]
            corp_line += f'S0 R{SNAKES[0]["positions"][0][0]}C{SNAKES[0]["positions"][0][1]} L{SNAKES[0]["tail_lengths"][0]} '
            # [apples_positions[0]]
            corp_line += " ".join([f'A{r}{c}' for r,c in APPLES[apple_i]["positions"]])
            corp_line += " "

         
            # [Snake1_positions[1]]
            corp_line += f'S1 R{SNAKES[1]["positions"][0][0]}C{SNAKES[1]["positions"][0][1]} L{SNAKES[1]["tail_lengths"][0]} '
            # [apples_positions[0]]
            corp_line += " ".join([f'A{r}{c}' for r,c in APPLES[apple_i]["positions"]])
            corp_line += " "

            apple_i = 1

            # TURNS + 1 since last turn is also imporant (has a move that resulted in death of the other snake)
            for turn in range(1, TURNS+1):
                
                # 0th snake if move exists
                if (turn-1) % 2 == 0:
                    if si[0] < len(SNAKES[0]["positions"]):
                        # S0 12 7 -> Snake0 is on position (1,2) and has a tail of length 7
                        corp_line += f'S0 R{SNAKES[0]["positions"][si[0]][0]}C{SNAKES[0]["positions"][si[0]][1]} L{SNAKES[0]["tail_lengths"][si[0]]} '
                        # after a move save apple position
                        if apple_i < len(APPLES):
                            corp_line += " ".join([f'A{r}{c}' for r,c in APPLES[apple_i]["positions"]])
                            # corp_line += " "
                            apple_i += 1

                        si[0] += 1
                    else:
                        corp_line += f'S0 <DEAD> L{SNAKES[0]["tail_lengths"][-1]} '
                        corp_line += " ".join([f'A{r}{c}' for r,c in APPLES[apple_i-1]["positions"]])

                # 1st snake if move exists
                elif (turn-1) % 2 == 1:
                    if si[1] < len(SNAKES[1]["positions"]):
                        # S1 12 7 -> Snake1 is on position (1,2) and has a tail of length 7
                        corp_line += f'S1 R{SNAKES[1]["positions"][si[1]][0]}C{SNAKES[1]["positions"][si[1]][1]} L{SNAKES[1]["tail_lengths"][si[1]]} '

                        # after a move save apple position
                        if apple_i < len(APPLES):
                            corp_line += " ".join([f'A{r}{c}' for r,c in APPLES[apple_i]["positions"]])
                            # corp_line += " "
                            apple_i += 1
                            

                        si[1] += 1
                    else:
                        corp_line += f'S1 <DEAD> L{SNAKES[1]["tail_lengths"][-1]} '
                        corp_line += " ".join([f'A{r}{c}' for r,c in APPLES[apple_i-1]["positions"]])
                
                corp_line += " "

            corpora.append(corp_line.strip() + ' <END>')

        return corpora
    


    def parse_raw_data_to_tokens_last_segment(self):
        """
            Takes data from raw data and returns games in a form of:
            <START> S0 R8C0 L0 A39 A90 A17 A88 A73 S1 R8C2 L0 A39 A90 A17 A88 A73 S0 R9C0 L1 ...
        """

        self.games = self.load_raw_data()


        corpora = []
        for game in self.games:

            TURNS = game["turns"]
            SNAKES = game["snakes"]
            APPLES = game["apples"]

            
            corp_line = "<START> "

            si = [1 for _ in range(len(SNAKES))]
            
            # set up initial snakes and apples positions
            apple_i = 0
            
            # [Snake0_positions[0]]
            corp_line += f'S0 R{SNAKES[0]["positions"][0][0]}C{SNAKES[0]["positions"][0][1]} L{SNAKES[0]["tail_lengths"][0]} <TAIL_END> R{SNAKES[0]["last_segments"][0][0]}C{SNAKES[0]["last_segments"][0][1]} '
            # [apples_positions[0]]
            corp_line += " ".join([f'A{r}{c}' for r,c in APPLES[apple_i]["positions"]])
            corp_line += " "

         
            # [Snake1_positions[1]]
            corp_line += f'S1 R{SNAKES[1]["positions"][0][0]}C{SNAKES[1]["positions"][0][1]} L{SNAKES[1]["tail_lengths"][0]} <TAIL_END> R{SNAKES[1]["last_segments"][0][0]}C{SNAKES[1]["last_segments"][0][1]} '
            # [apples_positions[0]]
            corp_line += " ".join([f'A{r}{c}' for r,c in APPLES[apple_i]["positions"]])
            corp_line += " "

            apple_i = 1

            # TURNS + 1 since last turn is also imporant (has a move that resulted in death of the other snake)
            for turn in range(1, TURNS+1):
                
                # 0th snake if move exists
                if (turn-1) % 2 == 0:
                    if si[0] < len(SNAKES[0]["positions"]):
                        # S0 12 7 -> Snake0 is on position (1,2) and has a tail of length 7
                        corp_line += f'S0 R{SNAKES[0]["positions"][si[0]][0]}C{SNAKES[0]["positions"][si[0]][1]} L{SNAKES[0]["tail_lengths"][si[0]]} <TAIL_END> R{SNAKES[0]["last_segments"][si[0]][0]}C{SNAKES[0]["last_segments"][si[0]][1]} '
                        # after a move save apple position
                        if apple_i < len(APPLES):
                            corp_line += " ".join([f'A{r}{c}' for r,c in APPLES[apple_i]["positions"]])
                            # corp_line += " "
                            apple_i += 1

                        si[0] += 1
                    else:
                        corp_line += f'S0 <DEAD> L{SNAKES[0]["tail_lengths"][-1]} <TAIL_END> R{SNAKES[0]["last_segments"][-1][0]}C{SNAKES[0]["last_segments"][-1][1]} '
                        corp_line += " ".join([f'A{r}{c}' for r,c in APPLES[apple_i-1]["positions"]])

                # 1st snake if move exists
                elif (turn-1) % 2 == 1:
                    if si[1] < len(SNAKES[1]["positions"]):
                        # S1 12 7 -> Snake1 is on position (1,2) and has a tail of length 7
                        corp_line += f'S1 R{SNAKES[1]["positions"][si[1]][0]}C{SNAKES[1]["positions"][si[1]][1]} L{SNAKES[1]["tail_lengths"][si[1]]} <TAIL_END> R{SNAKES[1]["last_segments"][si[1]][0]}C{SNAKES[1]["last_segments"][si[1]][1]} '

                        # after a move save apple position
                        if apple_i < len(APPLES):
                            corp_line += " ".join([f'A{r}{c}' for r,c in APPLES[apple_i]["positions"]])
                            # corp_line += " "
                            apple_i += 1
                            

                        si[1] += 1
                    else:
                        corp_line += f'S1 <DEAD> L{SNAKES[1]["tail_lengths"][-1]} <TAIL_END> R{SNAKES[1]["last_segments"][-1][0]}C{SNAKES[1]["last_segments"][-1][1]} '
                        corp_line += " ".join([f'A{r}{c}' for r,c in APPLES[apple_i-1]["positions"]])
                
                corp_line += " "

            corpora.append(corp_line.strip() + ' <END>\n')

        return corpora
    

    def create_last_segment_corpora(self, output_folder: pathlib.Path, output_filename: pathlib.Path):
        last_segment_corpora = [line.strip() for line in self.parse_raw_data_to_tokens_last_segment()]
        
        self.file_save_create_stats_file(corpora=last_segment_corpora, output_folder=output_folder, output_filename=output_filename)

    def create_standard_position_corpora(self, output_folder: pathlib.Path, output_filename: pathlib.Path):
        # to pewnie trzeba zmienić żeby wykorzystywać jedną funkcję parsującą
        standard_corpora = self.parse_raw_data_to_tokens()
        
        self.file_save_create_stats_file(standard_corpora, output_folder, output_filename)


    def create_apple_corpora(self, output_folder: pathlib.Path, output_filename: pathlib.Path):
        """
            Creates corpora, where apple token is present only if it was recently added,
            no change in apples state results with a special token <APPLES_UNCHANGED>
        """

        standard_corpora = self.parse_raw_data_to_tokens()

        apple_corpora = []

        for game in standard_corpora:
            tokens = game.split()
            l = 0
            prev_apples = []
            corpline = ""

            while l < len(tokens):
                r = l
                while tokens[r].startswith("A"):
                    r += 1
                # window of apples was encountered
                if r != l:
                    # apples didn't change
                    if prev_apples == tokens[l:r]:
                        corpline += " <APPLES_UNCHANGED>"
                    else:
                        # apples changed, so just add the apple where they differ as apple
                        # leave only new apple
                        diff = list(set(tokens[l:r]) - set(prev_apples))
                        # logger.debug(prev_apples)
                        # logger.debug(tokens[l:r])
                        # logger.debug(diff)
                        # logger.debug(len(diff))
                        assert len(diff) == 1 or prev_apples == []
                        assert diff[0] in tokens[l:r]
                        assert diff[0] not in prev_apples
                        corpline += " " + " ".join([elem for elem in diff]) 


                    prev_apples = tokens[l:r]
                    # move window to the first, not apple token
                    l = r
                    

                # it wasn't a window of apples, so just add normal token
                else:
                    corpline += " " + tokens[l]
                    l += 1

            apple_corpora.append(corpline)

        with open(output_folder / output_filename, 'w+') as file:
            for game_line in apple_corpora:
                file.write(game_line + "\n")

        self.get_statistics(corpora_folder=output_folder, stats_of_filename=output_filename)


    def file_save_create_stats_file(self, corpora: List[str],  output_folder: pathlib.Path, output_filename: pathlib.Path):
        with open(output_folder / output_filename, 'w+') as file:
            for game_line in corpora:
                file.write(game_line + "\n")

        self.get_statistics(corpora_folder=output_folder, stats_of_filename=output_filename)


        
    def create_no_tail_corpora(self, output_folder: pathlib.Path, output_filename: pathlib.Path):
        standard_corpora = self.parse_raw_data_to_tokens()

        no_tails_corpora = []

        for game in standard_corpora:
            no_tail_game = re.sub(r'\sL\d+', '', game.strip())
            no_tails_corpora.append(no_tail_game)

        
        self.file_save_create_stats_file(corpora=no_tails_corpora, output_folder=output_folder, output_filename=output_filename)


    def create_minimal_corpora(self, output_folder: pathlib.Path, output_filename: pathlib.Path, path_to_apple_corpora: pathlib.Path = None):
        """
            Effectively creates apple corpora, but without the tails tokens.
        """
        if not path_to_apple_corpora or not path_to_apple_corpora.exists():
            raise ValueError("Path to apple corpora must be provided for minimal corpora creation.")

        minimal_corpora = []

        with open(path_to_apple_corpora, 'r') as file:
            apple_corpora = [line.strip() for line in file if line.strip()]
            
        for game in apple_corpora:
            # remove tail tokens
            no_tail_game = re.sub(r'\sL\d+', '', game.strip())
            minimal_corpora.append(no_tail_game)
        self.file_save_create_stats_file(corpora=minimal_corpora, output_folder=output_folder, output_filename=output_filename)
    
    
    def create_determine_winner_corpora(self, output_folder: pathlib.Path, output_filename: pathlib.Path) -> str:



        standard_corpora = self.parse_raw_data_to_tokens()

        # print(f"Number of games in standard corpora: {len(standard_corpora)}")

        determined_winner_corpus = []
        
        for game in standard_corpora:
            tokens = game.split()

            # print(tokens)

            # find you who has longer tail at the end of the game
            max_tail_0 = 0
            max_tail_1 = 0
            for i,t in enumerate(tokens):

                direct_number = -1
                if t == "S0" or t == "S1":
                
                    match = re.search(r'L(\d+)', tokens[i + 2])
                    
                    if match:
                        direct_number = int(match.group(1))
                    else:
                        raise ValueError("Expected Length to be a number!")
                
                if t == "S0":
                    max_tail_0 = max(direct_number, max_tail_0)
                elif t == "S1":
                    max_tail_1 = max(direct_number, max_tail_1)
                else:
                    continue
                
            
            if max_tail_0 > max_tail_1:
                determined_winner_corpus.append("<SNAKE0_WINS> " + game)
            elif max_tail_0 < max_tail_1:
                determined_winner_corpus.append("<SNAKE1_WINS> " + game)
            else:
                determined_winner_corpus.append("<DRAW> " + game)

        self.file_save_create_stats_file(corpora=determined_winner_corpus, output_folder=output_folder, output_filename=output_filename)




if __name__ == "__main__":
    
    # creator = CorporaCreator(delimenter=CORPORA_DELIMETER, path_to_raw_data=RAW_DATA_TAILS_20K)
    creator = CorporaCreator(delimenter=CORPORA_DELIMETER, path_to_raw_data=RAW_DATA_MCTS_20K)

    COPR_DIR = CORPORA_DIR / pathlib.Path("mcts_standard_win_lost")
    OUT_CORP_FILE = pathlib.Path("mcts_standard_win_lost.txt")
    
    # creator.create_apple_corpora(output_folder=COPR_DIR, output_filename=OUT_CORP_FILE)

    # creator.create_last_segment_corpora(output_folder=COPR_DIR, output_filename=OUT_CORP_FILE)
    # creator.create_standard_position_corpora(output_folder=COPR_DIR, output_filename=OUT_CORP_FILE)
    creator.create_determine_winner_corpora(output_folder=COPR_DIR, output_filename=OUT_CORP_FILE)
    # creator.create_no_tail_corpora(output_folder=COPR_DIR, output_filename=OUT_CORP_FILE)
    # creator.create_minimal_corpora(output_folder=COPR_DIR, output_filename=OUT_CORP_FILE, path_to_apple_corpora=CORPORA_DIR / pathlib.Path("apples_corpora/apples_corpora20k.txt"))

    # COPR_DIR = CORPORA_DIR / pathlib.Path("standard_positions/")
    # OUT_CORP_FILE = pathlib.Path("standard_positions20kp.txt")

    # STANDARD POSITIONS GENERATION
    # creator.create_standard_position_corpora(
    #                         output_filename=OUT_CORP_FILE,
    #                         output_folder=COPR_DIR)
    
    

    # creator.get_statistics(corpora_folder=COPR_DIR, stats_of_filename=OUT_CORP_FILE)

    # ALIGNED POSITIONS GENERATOR

    # COPR_DIR = CORPORA_DIR / pathlib.Path("aligned_games/")
    # OUT_CORP_FILE = pathlib.Path("aligned_games20k.txt")

    # creator.create_standard_corpora_aligned(output_folder=COPR_DIR, output_filename=OUT_CORP_FILE)

    # creator.get_statistics(corpora_folder=COPR_DIR, stats_of_filename=OUT_CORP_FILE)
